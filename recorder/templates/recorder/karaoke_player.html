<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>üé§ Karaoke Reels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <style>
  * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      -webkit-tap-highlight-color: transparent;
  }
  html, body {
      overflow: hidden !important;
      width: 100% !important;
      height: 100% !important;
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      background: #000 !important;
      touch-action: manipulation;
  }
  body { 
      background: #000; 
      font-family: 'Poppins', sans-serif; 
      height: 100% !important;
      width: 100% !important;
      overflow: hidden !important;
      position: fixed !important;
      margin: 0 !important;
      padding: 0 !important;
  }
  .karaoke-wrapper {
      width: 100% !important;
      height: 100% !important;
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      background: #111 !important;
      overflow: hidden !important;
      aspect-ratio: 9/16 !important;
  }
  #status { 
      position: absolute; 
      top: 10px; 
      width: 100%; 
      text-align: center; 
      font-size: 12px; 
      color: #ccc; 
      z-index: 20; 
      text-shadow: 1px 1px 6px rgba(0,0,0,0.9); 
      padding: 5px;
  }
  .reel-bg { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100% !important; 
      height: 75% !important;          /* Image occupies 75% of the screen */
      object-fit: contain !important;
      object-position: center !important;
  }
  .controls { 
      position: absolute; 
      top: 76% !important;              /* 75% image + 1% gap */
      left: 0;
      width: 100%;
      text-align: center; 
      z-index: 30; 
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 5px;
      padding: 10px;
      box-sizing: border-box;
  }
  button { 
      background: linear-gradient(135deg, #ff0066, #ff66cc); 
      border: none; 
      color: white; 
      padding: 10px 15px; 
      border-radius: 20px; 
      font-size: 12px; 
      margin: 2px; 
      box-shadow: 0px 3px 15px rgba(255,0,128,0.4); 
      cursor: pointer; 
      min-width: 100px;
      flex: 1;
      max-width: 150px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
  }
  button:active { 
      transform: scale(0.95); 
      opacity: 0.9;
  }
  #logoImg { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      width: 30px;
      height: 30px;
      z-index: 50; 
      opacity: 1;
      filter: brightness(1.2);
  }
  .final-output { 
      position: absolute !important; 
      width: 100% !important; 
      height: 100% !important; 
      top: 0 !important; 
      left: 0 !important; 
      background: rgba(0,0,0,0.95); 
      display: none; 
      justify-content: center; 
      align-items: center; 
      z-index: 999; 
  }
  .audio-player {
      display: none;
  }
  #recordingVideoPlayer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: none;
      z-index: 1000;
  }
  .video-controls {
      position: absolute;
      bottom: 10%;
      width: 100%;
      text-align: center;
      z-index: 1001;
      display: flex;
      justify-content: center;
      gap: 10px;
  }
  .video-controls button {
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.3);
  }
  canvas { 
      display: none; 
  }
  </style>
</head>
<body>
  <div class="karaoke-wrapper" id="karaokeWrapper">
      <!-- Background image -->
      {% if song.lyrics_image %}
      <img class="reel-bg" id="mainBg" src="{{ song.lyrics_image.url }}">
      {% else %}
      <img class="reel-bg" id="mainBg" src="/static/default_lyrics_bg.jpg">
      {% endif %}

      <!-- Logo -->
      <img id="logoImg" src="/media/logo/branks3_logo.png" onerror="this.style.display='none'">

      <!-- Status text -->
      <div id="status">Ready üé§ Tap screen first</div>

      <!-- Hidden audio elements -->
      <audio id="originalAudio" class="audio-player" preload="auto" src="{{ song.original_file.url }}"></audio>
      <audio id="accompaniment" class="audio-player" preload="auto" src="{{ song.accompaniment_file.url }}"></audio>

      <!-- Controls ‚Äì now placed directly below the image with a 1% gap -->
      <div class="controls">
        <button id="playBtn">‚ñ∂ Play Original</button>
        <button id="recordBtn">üéô Start Recording</button>
        <button id="stopBtn" style="display:none;">‚èπ Stop Recording</button>
      </div>
  </div>

  <!-- Final output screen (after recording) -->
  <div class="final-output" id="finalOutputDiv">
    <div class="karaoke-wrapper">
      <img class="reel-bg" id="finalBg">
      <div id="finalStatus">Recording Complete!</div>
      <div class="controls">
        <button id="playRecordingBtn">‚ñ∂ Play</button>
        <a id="downloadRecordingBtn" href="#" download>
          <button>‚¨á Download</button>
        </a>
        <button id="newRecordingBtn">New</button>
      </div>
    </div>
  </div>

  <!-- Video player for playback -->
  <video id="recordingVideoPlayer" controls></video>
  <div class="video-controls" id="videoControls" style="display:none;">
    <button onclick="closeVideoPlayer()">Close</button>
    <button onclick="toggleFullscreen()">Fullscreen</button>
  </div>

  <!-- Canvas for video recording (hidden) -->
  <canvas id="recordingCanvas"></canvas>

  <script>
  /* ================== GLOBAL STATE ================== */
  let mediaRecorder;
  let recordedChunks = [];
  let lastRecordingURL = null;
  let audioContext, micSource, accSource, micGain, accGain, destination, originalSource;
  let canvasRafId = null;
  let isRecording = false;
  let isPlayingRecording = false;
  let autoStopTimer = null;
  let isSongPlaying = false;
  let micStream = null;
  let recordingStartTime = 0;
  let recordingDuration = 0;
  let originalAudioBuffer = null;
  let accompanimentBuffer = null;

  /* ================== ELEMENTS ================== */
  const playBtn = document.getElementById("playBtn");
  const recordBtn = document.getElementById("recordBtn");
  const stopBtn = document.getElementById("stopBtn");
  const status = document.getElementById("status");
  const originalAudio = document.getElementById("originalAudio");
  const accompanimentAudio = document.getElementById("accompaniment");
  const finalDiv = document.getElementById("finalOutputDiv");
  const mainBg = document.getElementById("mainBg");
  const finalBg = document.getElementById("finalBg");
  const finalStatus = document.getElementById("finalStatus");
  const playRecordingBtn = document.getElementById("playRecordingBtn");
  const downloadRecordingBtn = document.getElementById("downloadRecordingBtn");
  const newRecordingBtn = document.getElementById("newRecordingBtn");
  const canvas = document.getElementById("recordingCanvas");
  const ctx = canvas.getContext("2d");
  const logoImg = new Image();
  logoImg.src = document.getElementById("logoImg").src;
  const recordingVideoPlayer = document.getElementById("recordingVideoPlayer");
  const videoControls = document.getElementById("videoControls");

  /* ================== CANVAS SETUP ================== */
  canvas.width = 720;
  canvas.height = 1280;

  /* ================== AUDIO CONTEXT ================== */
  async function ensureAudioContext() {
      if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)({
              sampleRate: 48000,
              latencyHint: 'playback'
          });
      }
      if (audioContext.state === "suspended") {
          await audioContext.resume();
      }
      return audioContext;
  }

  /* ================== LOAD AUDIO BUFFERS ================== */
  async function loadAudioBuffers() {
      const audioCtx = await ensureAudioContext();

      // Fetch original
      const originalRes = await fetch(originalAudio.src);
      const originalArrayBuffer = await originalRes.arrayBuffer();
      originalAudioBuffer = await audioCtx.decodeAudioData(originalArrayBuffer);

      // Fetch accompaniment
      const accRes = await fetch(accompanimentAudio.src);
      const accArrayBuffer = await accRes.arrayBuffer();
      accompanimentBuffer = await audioCtx.decodeAudioData(accArrayBuffer);

      console.log("‚úÖ Audio buffers loaded:");
      console.log("- Original duration:", originalAudioBuffer.duration);
      console.log("- Accompaniment duration:", accompanimentBuffer.duration);
  }

  /* ================== PLAY/STOP ORIGINAL ================== */
  playBtn.onclick = async function() {
      await ensureAudioContext();

      if (!originalAudioBuffer) {
          await loadAudioBuffers();
      }

      if (!isSongPlaying) {
          // Play original through Web Audio for better control
          originalSource = audioContext.createBufferSource();
          originalSource.buffer = originalAudioBuffer;
          originalSource.connect(audioContext.destination);
          originalSource.start();

          isSongPlaying = true;
          playBtn.innerText = "‚èπ Stop Original";
          status.innerText = "üéµ Playing original song...";

          originalSource.onended = () => {
              isSongPlaying = false;
              playBtn.innerText = "‚ñ∂ Play Original";
              status.innerText = "‚úÖ Song finished";
          };
      } else {
          if (originalSource) {
              originalSource.stop();
              originalSource.disconnect();
              originalSource = null;
          }
          isSongPlaying = false;
          playBtn.innerText = "‚ñ∂ Play Original";
          status.innerText = "‚èπ Stopped";
      }
  };

  /* ================== CANVAS DRAWING ================== */
  function drawCanvas() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const canvasW = canvas.width;
      const canvasH = canvas.height * 0.75;

      const imgRatio = mainBg.naturalWidth / mainBg.naturalHeight;
      const canvasRatio = canvasW / canvasH;

      let drawW, drawH;
      if (imgRatio > canvasRatio) {
          drawW = canvasW;
          drawH = canvasW / imgRatio;
      } else {
          drawH = canvasH;
          drawW = canvasH * imgRatio;
      }

      const x = (canvasW - drawW) / 2;
      const y = 0;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(mainBg, x, y, drawW, drawH);

      const logoSize = 60;
      ctx.drawImage(logoImg, 20, 20, logoSize, logoSize);

      canvasRafId = requestAnimationFrame(drawCanvas);
  }

  /* ================== RECORDING ================== */
  recordBtn.onclick = async function() {
      if (isRecording) return;

      isRecording = true;
      playBtn.style.display = "none";
      recordBtn.style.display = "none";
      stopBtn.style.display = "inline-block";
      status.innerText = "üéô Starting recording...";

      try {
          const audioCtx = await ensureAudioContext();

          if (autoStopTimer) clearTimeout(autoStopTimer);

          // Stop any playing song
          if (isSongPlaying && originalSource) {
              originalSource.stop();
              originalSource.disconnect();
              originalSource = null;
              isSongPlaying = false;
          }

          if (!originalAudioBuffer || !accompanimentBuffer) {
              await loadAudioBuffers();
          }

          // Play original song through a separate <audio> element (not recorded)
          const playbackAudio = new Audio(originalAudio.src);
          playbackAudio.volume = 1.0;
          playbackAudio.play().catch(e => console.log("Playback error:", e));

          // Get microphone
          micStream = await navigator.mediaDevices.getUserMedia({
              audio: {
                  echoCancellation: false,
                  noiseSuppression: true,
                  autoGainControl: false,
                  channelCount: 1,
                  sampleRate: 48000,
                  sampleSize: 24,
                  latency: 0.01
              },
              video: false
          }).catch(err => {
              status.innerText = "‚ùå Microphone access required";
              resetUIOnError();
              throw err;
          });

          micSource = audioCtx.createMediaStreamSource(micStream);

          accSource = audioCtx.createBufferSource();
          accSource.buffer = accompanimentBuffer;

          const actualDuration = accompanimentBuffer.duration;
          console.log("‚úÖ Actual accompaniment duration:", actualDuration, "seconds");

          micGain = audioCtx.createGain();
          micGain.gain.value = 1.5;  // voice volume

          accGain = audioCtx.createGain();
          accGain.gain.value = 0.4;  // accompaniment volume

          destination = audioCtx.createMediaStreamDestination();

          micSource.connect(micGain);
          micGain.connect(destination);
          accSource.connect(accGain);
          accGain.connect(destination);

          drawCanvas();

          accSource.start();

          const canvasStream = canvas.captureStream(30);
          const mixedAudioStream = destination.stream;
          const combinedStream = new MediaStream([
              ...canvasStream.getVideoTracks(),
              ...mixedAudioStream.getAudioTracks()
          ]);

          let mimeType = 'video/mp4;codecs=avc1.42E01E,mp4a.40.2';
          if (!MediaRecorder.isTypeSupported(mimeType)) {
              mimeType = 'video/webm;codecs=vp9,opus';
          }
          if (!MediaRecorder.isTypeSupported(mimeType)) {
              mimeType = 'video/webm;codecs=vp8,opus';
          }
          if (!MediaRecorder.isTypeSupported(mimeType)) {
              mimeType = 'video/webm';
          }

          mediaRecorder = new MediaRecorder(combinedStream, {
              mimeType: mimeType,
              audioBitsPerSecond: 256000,
              videoBitsPerSecond: 5000000,
              videoKeyFrameInterval: 30
          });

          recordedChunks = [];
          recordingStartTime = Date.now();

          mediaRecorder.ondataavailable = e => {
              if (e.data.size > 0) recordedChunks.push(e.data);
          };

          mediaRecorder.onstop = () => {
              cancelAnimationFrame(canvasRafId);
              recordingDuration = (Date.now() - recordingStartTime) / 1000;

              playbackAudio.pause();
              playbackAudio.currentTime = 0;

              cleanupAudioSources();

              if (recordedChunks.length > 0) {
                  const blob = new Blob(recordedChunks, { type: mimeType });
                  const url = URL.createObjectURL(blob);

                  if (lastRecordingURL) URL.revokeObjectURL(lastRecordingURL);
                  lastRecordingURL = url;

                  finalBg.src = mainBg.src;
                  finalDiv.style.display = "flex";

                  const minutes = Math.floor(recordingDuration / 60);
                  const seconds = Math.floor(recordingDuration % 60);
                  finalStatus.innerText = `‚úÖ Recording Complete! (${minutes}:${seconds.toString().padStart(2, '0')})`;

                  // Generate file name
                  const songName = "{{ song.title|default:'karaoke' }}".replace(/[^a-zA-Z0-9]/g, '_');
                  let extension = mimeType.includes('mp4') ? '_KARAOKE.mp4' : '_KARAOKE.webm';
                  const fileName = songName + extension;
                  downloadRecordingBtn.href = url;
                  downloadRecordingBtn.download = fileName;

                  playRecordingBtn.onclick = () => {
                      if (!isPlayingRecording) {
                          recordingVideoPlayer.src = url;
                          recordingVideoPlayer.style.display = 'block';
                          videoControls.style.display = 'flex';
                          finalDiv.style.display = 'none';
                          recordingVideoPlayer.play();
                          playRecordingBtn.innerText = "‚èπ Stop";
                          isPlayingRecording = true;

                          recordingVideoPlayer.onended = () => {
                              closeVideoPlayer();
                              playRecordingBtn.innerText = "‚ñ∂ Play";
                              isPlayingRecording = false;
                          };
                      } else {
                          closeVideoPlayer();
                          playRecordingBtn.innerText = "‚ñ∂ Play";
                          isPlayingRecording = false;
                      }
                  };
              }
          };

          mediaRecorder.start(1000);
          status.innerText = "üéô Recording...";

          autoStopTimer = setTimeout(() => {
              if (isRecording) {
                  stopRecording();
                  status.innerText = "‚úÖ Auto-stopped: Recording complete!";
              }
          }, (actualDuration * 1000) + 1000);

      } catch (error) {
          console.error("Recording error:", error);
          status.innerText = "‚ùå Failed: " + (error.message || "Check microphone access");
          resetUIOnError();
      }
  };

  /* ================== CLEANUP ================== */
  function cleanupAudioSources() {
      if (accSource) {
          try { accSource.stop(); accSource.disconnect(); } catch(e) {}
          accSource = null;
      }
      if (originalSource) {
          try { originalSource.stop(); originalSource.disconnect(); } catch(e) {}
          originalSource = null;
      }
      if (micSource) {
          try { micSource.disconnect(); } catch(e) {}
          micSource = null;
      }
      if (micGain) {
          try { micGain.disconnect(); } catch(e) {}
          micGain = null;
      }
      if (accGain) {
          try { accGain.disconnect(); } catch(e) {}
          accGain = null;
      }
      if (destination) {
          try { destination.disconnect(); } catch(e) {}
          destination = null;
      }
      if (micStream) {
          micStream.getTracks().forEach(track => track.stop());
          micStream = null;
      }
  }

  function stopRecording() {
      if (!isRecording) return;
      if (autoStopTimer) clearTimeout(autoStopTimer);
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
      }
      cleanupAudioSources();
      if (isSongPlaying && originalSource) {
          originalSource.stop();
          originalSource.disconnect();
          originalSource = null;
          isSongPlaying = false;
      }
      if (canvasRafId) {
          cancelAnimationFrame(canvasRafId);
          canvasRafId = null;
      }
      isRecording = false;
      stopBtn.style.display = "none";
      status.innerText = "Processing recording...";
  }

  stopBtn.onclick = function() {
      stopRecording();
  };

  function resetUIOnError() {
      isRecording = false;
      playBtn.style.display = "inline-block";
      playBtn.innerText = "‚ñ∂ Play Original";
      recordBtn.style.display = "inline-block";
      stopBtn.style.display = "none";
      isSongPlaying = false;
      if (originalSource) {
          originalSource.stop();
          originalSource.disconnect();
          originalSource = null;
      }
      if (autoStopTimer) clearTimeout(autoStopTimer);
      cleanupAudioSources();
  }

  /* ================== NEW RECORDING ================== */
  newRecordingBtn.onclick = function() {
      closeVideoPlayer();
      finalDiv.style.display = "none";

      if (isSongPlaying && originalSource) {
          originalSource.stop();
          originalSource.disconnect();
          originalSource = null;
          isSongPlaying = false;
      }

      playBtn.style.display = "inline-block";
      playBtn.innerText = "‚ñ∂ Play Original";
      recordBtn.style.display = "inline-block";
      stopBtn.style.display = "none";
      status.innerText = "Ready üé§";

      recordedChunks = [];
      isRecording = false;
      isPlayingRecording = false;
      recordingStartTime = 0;
      recordingDuration = 0;

      if (lastRecordingURL) {
          URL.revokeObjectURL(lastRecordingURL);
          lastRecordingURL = null;
      }
  };

  /* ================== VIDEO PLAYER FUNCTIONS ================== */
  function closeVideoPlayer() {
      if (recordingVideoPlayer) {
          recordingVideoPlayer.pause();
          recordingVideoPlayer.currentTime = 0;
          recordingVideoPlayer.style.display = 'none';
          videoControls.style.display = 'none';
          recordingVideoPlayer.src = '';
      }
      finalDiv.style.display = 'flex';
      playRecordingBtn.innerText = "‚ñ∂ Play";
      isPlayingRecording = false;
      if (document.fullscreenElement) {
          document.exitFullscreen();
      }
  }

  function toggleFullscreen() {
      if (!document.fullscreenElement) {
          recordingVideoPlayer.requestFullscreen().catch(err => {
              console.log("Fullscreen error:", err);
          });
      } else {
          document.exitFullscreen();
      }
  }

  /* ================== TOUCH INIT ================== */
  document.addEventListener('touchstart', async () => {
      await ensureAudioContext();
  }, { once: true });

  /* ================== INITIALIZE ================== */
  window.addEventListener('load', async () => {
      status.innerText = "Ready üé§";
      try {
          await ensureAudioContext();
          await loadAudioBuffers();
          status.innerText = "Ready üé§ - Click 'Play Original' to listen";
      } catch(e) {
          console.log("Initialization error:", e);
          status.innerText = "Ready üé§";
      }
  });

  /* ================== CLEANUP ================== */
  window.addEventListener('beforeunload', () => {
      if (lastRecordingURL) URL.revokeObjectURL(lastRecordingURL);
      if (audioContext) audioContext.close();
      cleanupAudioSources();
  });

  recordingVideoPlayer.addEventListener('click', function() {
      if (this.paused) this.play(); else this.pause();
  });

  document.addEventListener('fullscreenchange', function() {
      if (!document.fullscreenElement) {
          videoControls.style.display = 'flex';
      }
  });
  </script>
</body>
</html>
